<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>IgM / IgG — Scatter + Elbow + K-Means</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body { font-family:-apple-system, Segoe UI, Roboto, sans-serif; margin:18px; }
    h2 { margin:18px 0 8px; font-size:18px; font-weight:700; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(520px, 1fr)); gap:18px; }
    .card { border:1px solid #eee; border-radius:12px; padding:12px; box-shadow:0 1px 2px rgba(0,0,0,.05); }
    .card h4 { margin:0 0 8px; font-weight:600; }
    svg { display:block; }
    .axis text { font-size:11px; }
    .axis path, .axis line { stroke:#d0d0d0; }
    .legend { display:flex; gap:10px; flex-wrap:wrap; margin-top:6px; }
    .legend-item { display:inline-flex; align-items:center; gap:6px; font-size:12px; }
    .swatch { width:12px; height:12px; border-radius:3px; display:inline-block; }
    .error { color:#b00020; margin:8px 0; }

    /* Toolbar */
    .toolbar { position:sticky; top:0; background:#fff; padding:10px 12px; border:1px solid #eee; border-radius:10px; box-shadow:0 1px 2px rgba(0,0,0,.05); margin-bottom:12px; display:flex; gap:18px; align-items:center; flex-wrap:wrap; z-index:5; }
    .group { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .group > .label { font-weight:700; margin-right:4px; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid #e4e4e4; border-radius:999px; font-size:13px; }
    #panel-menu { display:flex; gap:8px; flex-wrap:wrap; flex:1; }
    .pill-all { margin-left:auto; } /* pushes All Panels to the right */
  </style>
</head>
<body>

<div id="msg" class="error"></div>

<!-- Toolbar -->
<div class="toolbar">
  <div class="group" style="flex:1">
    <span class="label">Panels:</span>
    <div id="panel-menu"></div>
  </div>
  <div class="group">
    <span class="label">Clusters:</span>
    <div id="cluster-menu"></div>
  </div>
</div>

<!-- Section 1: Basic Scatter -->
<h2>1) Scatter (Raw TP vs FP)</h2>
<div class="grid">
  <div class="card" id="card-igm-basic"><h4>IgM — Raw Scatter</h4><div id="igm-basic"></div></div>
  <div class="card" id="card-igg-basic"><h4>IgG — Raw Scatter</h4><div id="igg-basic"></div></div>
</div>

<!-- Section 2: K-Means Scatter -->
<h2>2) K-Means Clusters (k=6)</h2>
<div class="grid">
  <div class="card" id="card-igm-kmeans"><h4>IgM — K-Means Clusters</h4><div id="igm-kmeans"></div><div id="igm-legend" class="legend"></div></div>
  <div class="card" id="card-igg-kmeans"><h4>IgG — K-Means Clusters</h4><div id="igg-kmeans"></div><div id="igg-legend" class="legend"></div></div>
</div>

<!-- Section 3: Elbow -->
<h2>3) Elbow (k vs Inertia)</h2>
<div class="grid">
  <div class="card" id="card-igm-elbow"><h4>IgM — Elbow</h4><div id="igm-elbow"></div></div>
  <div class="card" id="card-igg-elbow"><h4>IgG — Elbow</h4><div id="igg-elbow"></div></div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", () => {
  const FILES = {
    igmRaw:"../../data/df_igm_metrics.csv", iggRaw:"../../data/df_igg_metrics.csv",
    igmElbow:"../../data/igm_elbow.csv",    iggElbow:"../../data/igg_elbow.csv",
    igmClusters:"../../data/igm_clusters_k6.csv", iggClusters:"../../data/igg_clusters_k6.csv"
  };
  const BASE = new URL(".", location.href);
  const urlOf = f => new URL(f, BASE).toString();

  const W=520, H=420, M={top:22,right:16,bottom:44,left:48};
  const iw=W-M.left-M.right, ih=H-M.top-M.bottom;

  const msg = document.getElementById("msg");
  const showError = t => { console.error(t); msg.textContent = t; };
  const color = d3.scaleOrdinal(d3.schemeSet2);

  function mk(sel){
    return d3.select(sel).html("")
      .append("svg").attr("width",W).attr("height",H)
      .append("g").attr("transform",`translate(${M.left},${M.top})`);
  }
  function axes(svg,x,y,xLabel,yLabel){
    svg.append("g").attr("class","axis").attr("transform",`translate(0,${ih})`).call(d3.axisBottom(x).ticks(6));
    svg.append("g").attr("class","axis").call(d3.axisLeft(y).ticks(6));
    svg.append("text").attr("x",iw/2).attr("y",ih+34).attr("text-anchor","middle").text(xLabel);
    svg.append("text").attr("transform","rotate(-90)").attr("x",-ih/2).attr("y",-38).attr("text-anchor","middle").text(yLabel);
  }

  /* Slim, clean red × (two thin diagonals) */
  function drawCentroidX(svg, x, y, size=8, stroke="red", w=1.2){
    svg.append("line")
      .attr("x1", x-size).attr("y1", y-size).attr("x2", x+size).attr("y2", y+size)
      .attr("stroke", stroke).attr("stroke-width", w).attr("stroke-linecap","round");
    svg.append("line")
      .attr("x1", x-size).attr("y1", y+size).attr("x2", x+size).attr("y2", y-size)
      .attr("stroke", stroke).attr("stroke-width", w).attr("stroke-linecap","round");
  }

  function legend(containerSel, rows){
    const ids = Array.from(new Set(rows.map(d => +d.cluster))).sort(d3.ascending);
    const cont = d3.select(containerSel).html("");
    ids.forEach(c => {
      const item = cont.append("div").attr("class","legend-item");
      item.append("span").attr("class","swatch").style("background", color(c));
      item.append("span").text(`cluster ${c}`);
    });
  }

  // --- Basic Scatter ---
  function normalizeRow(d){
    const fp = d.FP ?? d.fp ?? d.fpr ?? d.false_positive_rate;
    const tp = d.TP ?? d.tp ?? d.tpr ?? d.true_positive_rate;
    return { device: d.device ?? d.Device ?? "", FP: +fp, TP: +tp };
  }
  function drawBasicScatter(sel, rows, colorVal){
    const data = rows.map(normalizeRow).filter(r => Number.isFinite(r.FP)&&Number.isFinite(r.TP));
    const svg = mk(sel);
    const x = d3.scaleLinear().domain([0,1]).range([0,iw]);
    const y = d3.scaleLinear().domain([0,1]).range([ih,0]);
    axes(svg,x,y,"False Positive Rate (FP)","True Positive Rate (TP)");
    svg.selectAll("circle").data(data).join("circle")
      .attr("cx",d=>x(d.FP)).attr("cy",d=>y(d.TP)).attr("r",4).attr("fill",colorVal)
      .append("title").text(d=>`${d.device||"(device)"}\nFP=${d.FP.toFixed(3)}  TP=${d.TP.toFixed(3)}`);
  }

  // --- K-Means Scatter ---
  function drawKMeansScatter(sel, legendSel, rows){
    const data = rows.map(d => ({ device:d.device??"", FP:+d.FP, TP:+d.TP, cluster:+d.cluster, panel:d.panel??"" }))
                     .filter(d => Number.isFinite(d.FP)&&Number.isFinite(d.TP));
    const svg = mk(sel);
    const x = d3.scaleLinear().domain([0,1]).range([0,iw]);
    const y = d3.scaleLinear().domain([0,1]).range([ih,0]);
    axes(svg,x,y,"False Positive Rate (FP)","True Positive Rate (TP)");

    svg.selectAll("circle.pt").data(data).join("circle")
      .attr("cx",d=>x(d.FP)).attr("cy",d=>y(d.TP)).attr("r",4).attr("fill",d=>color(d.cluster))
      .append("title").text(d=>`${d.device||"(device)"} • panel ${d.panel||"?"} • cluster ${d.cluster}\nFP=${d.FP.toFixed(3)}  TP=${d.TP.toFixed(3)}`);

    const cents = d3.rollups(data, v => ({ FP: d3.mean(v, d=>d.FP), TP: d3.mean(v, d=>d.TP) }), d => d.cluster)
                    .map(([cluster, c]) => ({ cluster:+cluster, ...c }));
    cents.forEach(c => drawCentroidX(svg, x(c.FP), y(c.TP), 9, "red", 1.2));

    legend(legendSel, data);
  }

  // --- Elbow ---
  function drawElbow(sel, data){
    const svg=mk(sel);
    const x=d3.scaleLinear().domain(d3.extent(data, d=>+d.k)).nice().range([0,iw]);
    const y=d3.scaleLinear().domain([0, d3.max(data, d=>+d.inertia)]).nice().range([ih,0]);
    axes(svg,x,y,"k (clusters)","Inertia");
    const line=d3.line().x(d=>x(+d.k)).y(d=>y(+d.inertia));
    svg.append("path").datum(data).attr("fill","none").attr("stroke","#444").attr("stroke-width",2).attr("d",line);
    svg.selectAll("circle.pt").data(data).join("circle")
      .attr("cx",d=>x(+d.k)).attr("cy",d=>y(+d.inertia)).attr("r",3).attr("fill","#444")
      .append("title").text(d=>`k=${d.k}, inertia=${(+d.inertia).toFixed(2)}`);
  }

  // --- UI helpers ---
  function setCardVisible(containerId, visible){
    const el = document.getElementById(containerId);
    if (!el) return;
    el.style.display = visible ? "" : "none";
  }

  // Checkbox builder with “All Panels” on the right
  function buildCheckboxes(containerSel, values, activeSet, onChange, isPanelMenu=false){
    const cont = d3.select(containerSel).html("");
    const sorted = Array.from(values).sort((a,b)=> (a+''>b+'')?1:-1);

    // Individual checkboxes (left)
    sorted.forEach(v => {
      const id = `${containerSel.replace('#','')}-${String(v).replace(/\W+/g,'-')}`;
      const pill = cont.append("label").attr("class","pill");
      pill.append("input")
        .attr("type","checkbox")
        .attr("id",id)
        .property("checked", activeSet.has(v))
        .on("change", function(){
          if (this.checked) activeSet.add(v); else activeSet.delete(v);
          if (isPanelMenu) syncAllPanelsCheckbox(containerSel, values, activeSet);
          onChange();
        });
      pill.append("span").text(v);
    });

    // “All Panels” at far right
    if (isPanelMenu) {
      const allPill = cont.append("label").attr("class","pill pill-all");
      const allId = containerSel.replace('#','')+"-all";
      allPill.append("input")
        .attr("type","checkbox")
        .attr("id", allId)
        .property("checked", activeSet.size === values.size)
        .on("change", function(){
          if (this.checked) values.forEach(v => activeSet.add(v));
          else activeSet.clear();
          // Rebuild to sync all the individual boxes, then render
          buildCheckboxes(containerSel, values, activeSet, onChange, true);
          onChange();
        });
      allPill.append("span").text("All Panels");
    }
  }

  function syncAllPanelsCheckbox(containerSel, values, activeSet){
    const allId = containerSel.replace('#','')+"-all";
    const allEl = document.getElementById(allId);
    if (allEl) allEl.checked = (activeSet.size === values.size);
  }

  // --- State ---
  let state = {
    panels: new Set(),          // Spike, Nucleocapsid, ... or fallback IgM/IgG
    activePanels: new Set(),
    clusters: new Set(),        // cluster IDs (1..k)
    activeClusters: new Set(),
    igmRaw: [], iggRaw: [],
    igmClu: [], iggClu: [],
    igmEl: [],  iggEl:  []
  };

  function ensurePanelsAndClusters() {
    // Fallback panel stamping if missing
    const igmHasPanel = state.igmClu.some(d => d.panel != null && d.panel !== "");
    const iggHasPanel = state.iggClu.some(d => d.panel != null && d.panel !== "");
    if (!igmHasPanel) state.igmClu.forEach(d => d.panel ??= "IgM");
    if (!iggHasPanel) state.iggClu.forEach(d => d.panel ??= "IgG");

    if (!state.igmEl.some(d => 'panel' in d)) state.igmEl.forEach(d => d.panel ??= "IgM");
    if (!state.iggEl.some(d => 'panel' in d)) state.iggEl.forEach(d => d.panel ??= "IgG");

    const allPanels = new Set();
    const allClusters = new Set();
    [...state.igmClu, ...state.iggClu].forEach(d => {
      if (d.panel) allPanels.add(String(d.panel));
    });
    // collect clusters from both sets
    [...state.igmClu, ...state.iggClu].forEach(d => {
      if (Number.isFinite(+d.cluster)) allClusters.add(+d.cluster);
    });

    if (allPanels.size === 0) { allPanels.add("IgM"); allPanels.add("IgG"); }
    state.panels = allPanels;
    state.activePanels = new Set(allPanels);

    state.clusters = allClusters.size ? allClusters : new Set([0,1,2,3,4,5,6]);
    state.activeClusters = new Set(state.clusters);
  }

  function filterKMeans(rows){
    return rows.filter(r =>
      state.activePanels.has(String(r.panel ?? "")) &&
      state.activeClusters.has(+r.cluster)
    );
  }

  function renderFiltered(){
    // K-Means
    const igmCluF = filterKMeans(state.igmClu);
    const iggCluF = filterKMeans(state.iggClu);
    drawKMeansScatter("#igm-kmeans", "#igm-legend", igmCluF);
    drawKMeansScatter("#igg-kmeans", "#igg-legend", iggCluF);

    // Elbow: show/hide cards by panel selection (panel names may not be literally "IgM"/"IgG")
    const hasIgM = [...state.activePanels].some(p => /igm/i.test(p) || p === "IgM");
    const hasIgG = [...state.activePanels].some(p => /igg/i.test(p) || p === "IgG");

    setCardVisible("card-igm-elbow", hasIgM);
    setCardVisible("card-igg-elbow", hasIgG);

    drawElbow("#igm-elbow", state.igmEl);
    drawElbow("#igg-elbow", state.iggEl);

    // K-Means cards also hide if empty after filtering
    setCardVisible("card-igm-kmeans", hasIgM && igmCluF.length > 0);
    setCardVisible("card-igg-kmeans", hasIgG && iggCluF.length > 0);
  }

  // --- Load + bootstrap ---
  Promise.all([
    d3.csv(urlOf(FILES.igmRaw), d3.autoType),
    d3.csv(urlOf(FILES.iggRaw), d3.autoType),
    d3.csv(urlOf(FILES.igmClusters), d3.autoType),
    d3.csv(urlOf(FILES.iggClusters), d3.autoType),
    d3.csv(urlOf(FILES.igmElbow), d3.autoType),
    d3.csv(urlOf(FILES.iggElbow), d3.autoType)
  ])
  .then(([igmRaw, iggRaw, igmClu, iggClu, igmEl, iggEl]) => {
    state.igmRaw = igmRaw; state.iggRaw = iggRaw;
    state.igmClu = igmClu; state.iggClu = iggClu;
    state.igmEl  = igmEl;  state.iggEl  = iggEl;

    // Section 1 (always visible)
    drawBasicScatter("#igm-basic", state.igmRaw, "#1f77b4");
    drawBasicScatter("#igg-basic", state.iggRaw, "#ff7f0e");

    // Build menus then initial render for Sections 2–3
    ensurePanelsAndClusters();
    buildCheckboxes("#panel-menu", state.panels, state.activePanels, renderFiltered, true); // All Panels on right
    buildCheckboxes("#cluster-menu", state.clusters, state.activeClusters, renderFiltered);
    renderFiltered();
  })
  .catch(err => { showError("Failed to load CSVs."); console.error(err); });

});
</script>
</body>
</html>
